{-# OPTIONS -w -O0 #-}
{-# LANGUAGE CPP, StandaloneDeriving, DeriveDataTypeable #-}
{- |
Module      :  Hybrid/ATC_Hybrid.der.hs
Description :  generated Typeable, ShATermConvertible instances
Copyright   :  (c) DFKI GmbH 2012
License     :  GPLv2 or higher, see LICENSE.txt

Maintainer  :  Christian.Maeder@dfki.de
Stability   :  provisional
Portability :  non-portable(derive Typeable instances)

Automatic derivation of instances via DrIFT-rule Typeable, ShATermConvertible
  for the type(s):
'Hybrid.AS_Hybrid.H_BASIC_ITEM'
'Hybrid.AS_Hybrid.RIGOR'
'Hybrid.AS_Hybrid.H_SIG_ITEM'
'Hybrid.AS_Hybrid.MODALITY'
'Hybrid.AS_Hybrid.NOMINAL'
'Hybrid.AS_Hybrid.H_FORMULA'
'Hybrid.HybridSign.HybridSign'
-}

{-
Generated by 'genRules' (automatic rule generation for DrIFT). Don't touch!!
  dependency files:
Hybrid/AS_Hybrid.hs
Hybrid/HybridSign.hs
-}

module Hybrid.ATC_Hybrid () where

import ATerm.Lib
import CASL.AS_Basic_CASL
import CASL.ATC_CASL
import CASL.Sign
import Common.AS_Annotation
import Common.Id
import Data.Typeable
import Hybrid.AS_Hybrid
import Hybrid.HybridSign
import qualified Common.Lib.MapSet as MapSet
import qualified Data.List as List
import qualified Data.Map as Map

{-! for Hybrid.AS_Hybrid.H_BASIC_ITEM derive : Typeable !-}
{-! for Hybrid.AS_Hybrid.RIGOR derive : Typeable !-}
{-! for Hybrid.AS_Hybrid.H_SIG_ITEM derive : Typeable !-}
{-! for Hybrid.AS_Hybrid.MODALITY derive : Typeable !-}
{-! for Hybrid.AS_Hybrid.NOMINAL derive : Typeable !-}
{-! for Hybrid.AS_Hybrid.H_FORMULA derive : Typeable !-}
{-! for Hybrid.HybridSign.HybridSign derive : Typeable !-}

{-! for Hybrid.AS_Hybrid.H_BASIC_ITEM derive : ShATermConvertible !-}
{-! for Hybrid.AS_Hybrid.RIGOR derive : ShATermConvertible !-}
{-! for Hybrid.AS_Hybrid.H_SIG_ITEM derive : ShATermConvertible !-}
{-! for Hybrid.AS_Hybrid.MODALITY derive : ShATermConvertible !-}
{-! for Hybrid.AS_Hybrid.NOMINAL derive : ShATermConvertible !-}
{-! for Hybrid.AS_Hybrid.H_FORMULA derive : ShATermConvertible !-}
{-! for Hybrid.HybridSign.HybridSign derive : ShATermConvertible !-}

-- Generated by DrIFT, look but don't touch!

instance ShATermConvertible H_FORMULA where
  toShATermAux att0 xv = case xv of
    At a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "At" [a', b', c'] []) att3
    BoxOrDiamond a b c d -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      (att4, d') <- toShATerm' att3 d
      return $ addATerm (ShAAppl "BoxOrDiamond" [a', b', c', d'] []) att4
    Here a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "Here" [a', b'] []) att2
    Univ a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "Univ" [a', b', c'] []) att3
    Exist a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "Exist" [a', b', c'] []) att3
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "At" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, At a' b' c') }}}
    ShAAppl "BoxOrDiamond" [a, b, c, d] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      case fromShATerm' d att3 of
      { (att4, d') ->
      (att4, BoxOrDiamond a' b' c' d') }}}}
    ShAAppl "Here" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, Here a' b') }}
    ShAAppl "Univ" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, Univ a' b' c') }}}
    ShAAppl "Exist" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, Exist a' b' c') }}}
    u -> fromShATermError "H_FORMULA" u

instance ShATermConvertible NOMINAL where
  toShATermAux att0 xv = case xv of
    Simple_nom a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "Simple_nom" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Simple_nom" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, Simple_nom a') }
    u -> fromShATermError "NOMINAL" u

instance ShATermConvertible MODALITY where
  toShATermAux att0 xv = case xv of
    Simple_mod a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "Simple_mod" [a'] []) att1
    Term_mod a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "Term_mod" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Simple_mod" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, Simple_mod a') }
    ShAAppl "Term_mod" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, Term_mod a') }
    u -> fromShATermError "MODALITY" u

instance ShATermConvertible H_SIG_ITEM where
  toShATermAux att0 xv = case xv of
    Rigid_op_items a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "Rigid_op_items" [a', b', c'] []) att3
    Rigid_pred_items a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "Rigid_pred_items" [a', b', c'] []) att3
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Rigid_op_items" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, Rigid_op_items a' b' c') }}}
    ShAAppl "Rigid_pred_items" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, Rigid_pred_items a' b' c') }}}
    u -> fromShATermError "H_SIG_ITEM" u

instance ShATermConvertible RIGOR where
  toShATermAux att0 xv = case xv of
    Rigid -> return $ addATerm (ShAAppl "Rigid" [] []) att0
    Flexible -> return $ addATerm (ShAAppl "Flexible" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Rigid" [] _ -> (att0, Rigid)
    ShAAppl "Flexible" [] _ -> (att0, Flexible)
    u -> fromShATermError "RIGOR" u

instance ShATermConvertible H_BASIC_ITEM where
  toShATermAux att0 xv = case xv of
    Simple_mod_decl a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "Simple_mod_decl" [a', b', c'] []) att3
    Term_mod_decl a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "Term_mod_decl" [a', b', c'] []) att3
    Simple_nom_decl a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "Simple_nom_decl" [a', b', c'] []) att3
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Simple_mod_decl" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, Simple_mod_decl a' b' c') }}}
    ShAAppl "Term_mod_decl" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, Term_mod_decl a' b' c') }}}
    ShAAppl "Simple_nom_decl" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, Simple_nom_decl a' b' c') }}}
    u -> fromShATermError "H_BASIC_ITEM" u

deriving instance Typeable H_FORMULA

deriving instance Typeable NOMINAL

deriving instance Typeable MODALITY

deriving instance Typeable H_SIG_ITEM

deriving instance Typeable RIGOR

deriving instance Typeable H_BASIC_ITEM

deriving instance Typeable HybridSign

instance ShATermConvertible HybridSign where
  toShATermAux att0 xv = case xv of
    HybridSign a b c d e -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      (att4, d') <- toShATerm' att3 d
      (att5, e') <- toShATerm' att4 e
      return $ addATerm (ShAAppl "HybridSign" [a', b', c', d',
                                               e'] []) att5
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "HybridSign" [a, b, c, d, e] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      case fromShATerm' d att3 of
      { (att4, d') ->
      case fromShATerm' e att4 of
      { (att5, e') ->
      (att5, HybridSign a' b' c' d' e') }}}}}
    u -> fromShATermError "HybridSign" u
